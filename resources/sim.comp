#version 430 core

#define SIMULATION_WIDTH 1920
#define SIMULATION_HEIGHT 1080
#define NUM_INDIVIDUALS 1000000
#define LOCAL_COMPUTE_SIZE 100
#define SIMULATION_SPEED 30
#define SAMPLE_DISTANCE 20
#define TURN_RATE 30

layout(local_size_x = 10) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(binding = 1) buffer cs_input_data {
    vec4 individuals[NUM_INDIVIDUALS];
};
layout(std430, binding = 2) buffer cs_time {
    float delta;
};

uint hash(uint x) {
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
}

float sample_image(ivec2 pos) {
    float sample_sum = 0.0;
    for(int x = max(0, pos.x - 1); x <= min(SIMULATION_WIDTH - 1, pos.x + 1); x ++) {
        for(int y = max(0, pos.y - 1); y <= min(SIMULATION_HEIGHT - 1, pos.y + 1); y ++) {
            vec3 sample_val = imageLoad(img_output, ivec2(x, y)).rgb;
            sample_sum += sample_val.r + sample_val.g + sample_val.b;
        }
    }
    return sample_sum;
}

void main() {
    for(int i = 0; i < LOCAL_COMPUTE_SIZE; i++) {
        vec2 pos = individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].xy;
        float angle = individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].z;

        float sample_front = sample_image(ivec2(pos.x + sin(angle) * SAMPLE_DISTANCE, pos.y + cos(angle) * SAMPLE_DISTANCE));
        float sample_left = sample_image(ivec2(pos.x + sin(angle - 0.5) * SAMPLE_DISTANCE, pos.y + cos(angle - 0.5) * SAMPLE_DISTANCE));
        float sample_right = sample_image(ivec2(pos.x + sin(angle + 0.5) * SAMPLE_DISTANCE, pos.y + cos(angle + 0.5) * SAMPLE_DISTANCE));
        uint rand0 = hash(uint(gl_GlobalInvocationID.x + i + pos.x + pos.y * SIMULATION_HEIGHT));
        uint rand1 = hash(rand0);

        if(sample_front > sample_left && sample_front > sample_right) {
            individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].z += 0.0;
        } else if (sample_front < sample_left && sample_front < sample_right) {
            individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].z += ((rand0 / 4294967295.0) - 0.5) * 2.0 * TURN_RATE * delta;
        } else if (sample_left > sample_right) {
            individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].z -= (rand0 / 4294967295.0) * TURN_RATE * delta;
        } else if (sample_left < sample_right) {
            individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].z += (rand0 / 4294967295.0) * TURN_RATE * delta;
        }

        vec2 new_pos = vec2(pos.x + sin(angle) * delta * SIMULATION_SPEED, pos.y + cos(angle) * delta * SIMULATION_SPEED);

        if (new_pos.x < 0 || new_pos.x >= SIMULATION_WIDTH || new_pos.y < 0 || new_pos.y >= SIMULATION_HEIGHT) {
            individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].z = rand1 / 4294967295.0 * 6.28319;
            new_pos.x = min(SIMULATION_WIDTH - 1, max(0, new_pos.x));
            new_pos.y = min(SIMULATION_HEIGHT - 1, max(0, new_pos.y));
        }

        individuals[gl_GlobalInvocationID.x * LOCAL_COMPUTE_SIZE + i].xy = new_pos;
        imageStore(img_output, ivec2(new_pos), vec4(1.0, 1.0, 1.0, 1.0));
    }
}